
        
Next up: Convert the entire program to format words as:
         jeo: ( [ (0) . ((A) -> (jeo A)) ]
                [ (c 1) . ((A B) -> (jeo A B)) ] )

--------------------------------------------------------

Commit: Make jado-ify transform (fa A B C) into e.g.
        (li ([jado 1] [jado 2]) (fa [do 1] [do 2] A))
        where "jado n" and "do n" might be just that or might
        represent some other regular notation for keeping
        variables straight.

Commit: Implement (reduce-li) function that takes a li-construct
        and changes the quantifiers to be in-place WHENEVER doing
        so does not change the meaning of the expression.

Next up: Make any necessary changes to covert words.scm to the
         new predicate format, then merge this branch back into
         master.


Idea:
-----
Re-conceive of predicates as being actual FUNCTIONS.  So:

    *dua* = (lambda (a b) `(dua ,a ,b))
    *mai* = (lambda (a b) `(mai ,a ,b))
    *leo* = (lambda (a b) `(leo ,a ,b))
    *dua mai* = (lambda (a b c) (dua a (mai b c)))
    *leo mai* = (lambda (a b) (leo a (mai jado b)))

A fully-fledged predicate would also need to carry around
its typelist, so in truth we would have:

    *dua* = ( '(c 0) . (lambda (a b) `(dua ,a ,b)) )

And since "each...word is really a family of...predicates":

    *jeo* = ( ( '(0)   . (lambda (a) `(jeo ,a)) )
              ( '(c 1) . (lambda (a b) `(jao ,a ,b))) )

Alternatively, a predicate could be represented as:

    *dua* = ( [lambda (a b) `(dua ,a ,b)] c 0 )